import{e as h,__tla as c}from"./index-BDXHqBW9.js";let a,s,l,d=Promise.all([(()=>{try{return c}catch{}})()]).then(async()=>{const{DISALLOWED:w}=h;class o{constructor(e,i){this.writer=e,this.fileEntry=i}async write(e){if(typeof e=="object"){if(e.type==="write"){if(Number.isInteger(e.position)&&e.position>=0&&(this.writer.seek(e.position),this.writer.position!==e.position&&(await new Promise((i,r)=>{this.writer.onwriteend=i,this.writer.onerror=r,this.writer.truncate(e.position)}),this.writer.seek(e.position))),!("data"in e))throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. write requires a data argument","SyntaxError");e=e.data}else if(e.type==="seek")if(Number.isInteger(e.position)&&e.position>=0){if(this.writer.seek(e.position),this.writer.position!==e.position)throw new DOMException("seeking position failed","InvalidStateError");return}else throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. seek requires a position argument","SyntaxError");else if(e.type==="truncate")return new Promise(i=>{if(Number.isInteger(e.size)&&e.size>=0)this.writer.onwriteend=r=>i(),this.writer.truncate(e.size);else throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. truncate requires a size argument","SyntaxError")})}await new Promise((i,r)=>{this.writer.onwriteend=i,this.writer.onerror=r,this.writer.write(new Blob([e]))})}close(){return new Promise(this.fileEntry.file.bind(this.fileEntry))}}a=class{constructor(t,e=!0){this.file=t,this.kind="file",this.writable=e,this.readable=!0}get name(){return this.file.name}isSameEntry(t){return this.file.toURL()===t.file.toURL()}getFile(){return new Promise(this.file.file.bind(this.file))}createWritable(t){if(!this.writable)throw new DOMException(...w);return new Promise((e,i)=>this.file.createWriter(r=>{t.keepExistingData===!1?(r.onwriteend=n=>e(new o(r,this.file)),r.truncate(0)):e(new o(r,this.file))},i))}},s=class{constructor(t,e=!0){this.dir=t,this.writable=e,this.readable=!0,this.kind="directory",this.name=t.name}isSameEntry(t){return this.dir.fullPath===t.dir.fullPath}async*entries(){const t=this.dir.createReader(),e=await new Promise(t.readEntries.bind(t));for(const i of e)yield[i.name,i.isFile?new a(i,this.writable):new s(i,this.writable)]}getDirectoryHandle(t,e){return new Promise((i,r)=>{this.dir.getDirectory(t,e,n=>{i(new s(n))},r)})}getFileHandle(t,e){return new Promise((i,r)=>this.dir.getFile(t,e,n=>i(new a(n)),r))}async removeEntry(t,e){const i=await this.getDirectoryHandle(t,{create:!1}).catch(r=>r.name==="TypeMismatchError"?this.getFileHandle(t,{create:!1}):r);if(i instanceof Error)throw i;return new Promise((r,n)=>{i instanceof s?e.recursive?i.dir.removeRecursively(()=>r(),n):i.dir.remove(()=>r(),n):i.file&&i.file.remove(()=>r(),n)})}},l=(t={})=>new Promise((e,i)=>window.webkitRequestFileSystem(t._persistent,0,r=>e(new s(r.root)),i))});export{a as FileHandle,s as FolderHandle,d as __tla,l as default};
