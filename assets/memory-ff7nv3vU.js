import{c as b,e as g,__tla as H}from"./index-DMCAZVB1.js";let h,l,f,_,E=Promise.all([(()=>{try{return H}catch{}})()]).then(async()=>{const{File:r,Blob:u,DOMException:s}=b,{INVALID:y,GONE:n,MISMATCH:c,MOD_ERR:p,SYNTAX:a,SECURITY:I,DISALLOWED:z}=g;f=class{constructor(i,e){this.fileHandle=i,this.file=e,this.size=e.size,this.position=0}write(i){let e=this.file;if(typeof i=="object"){if(i.type==="write"){if(Number.isInteger(i.position)&&i.position>=0&&(this.position=i.position,this.size<i.position&&(this.file=new r([this.file,new ArrayBuffer(i.position-this.size)],this.file.name,this.file))),!("data"in i))throw new s(...a("write requires a data argument"));i=i.data}else if(i.type==="seek")if(Number.isInteger(i.position)&&i.position>=0){if(this.size<i.position)throw new s(...y);this.position=i.position;return}else throw new s(...a("seek requires a position argument"));else if(i.type==="truncate")if(Number.isInteger(i.size)&&i.size>=0){e=i.size<this.size?new r([e.slice(0,i.size)],e.name,e):new r([e,new Uint8Array(i.size-this.size)],e.name),this.size=e.size,this.position>e.size&&(this.position=e.size),this.file=e;return}else throw new s(...a("truncate requires a size argument"))}i=new u([i]);let t=this.file;const o=t.slice(0,this.position),m=t.slice(this.position+i.size);let w=this.position-o.size;w<0&&(w=0),t=new r([o,new Uint8Array(w),i,m],t.name),this.size=t.size,this.position+=i.size,this.file=t}close(){if(this.fileHandle._deleted)throw new s(...n);this.fileHandle._file=this.file,this.file=this.position=this.size=null,this.fileHandle.onclose&&this.fileHandle.onclose(this.fileHandle)}},h=class{constructor(i="",e=new r([],i),t=!0){this._file=e,this.name=i,this.kind="file",this._deleted=!1,this.writable=t,this.readable=!0}async getFile(){if(this._deleted)throw new s(...n);return this._file}async createWritable(i){if(!this.writable)throw new s(...z);if(this._deleted)throw new s(...n);const e=i.keepExistingData?await this.getFile():new r([],this.name);return new f(this,e)}async isSameEntry(i){return this===i}async _destroy(){this._deleted=!0,this._file=null}},l=class{constructor(i,e=!0){this.name=i,this.kind="directory",this._deleted=!1,this._entries={},this.writable=e,this.readable=!0}async*entries(){if(this._deleted)throw new s(...n);yield*Object.entries(this._entries)}async isSameEntry(i){return this===i}async getDirectoryHandle(i,e){if(this._deleted)throw new s(...n);const t=this._entries[i];if(t){if(t instanceof h)throw new s(...c);return t}else{if(e.create)return this._entries[i]=new l(i);throw new s(...n)}}async getFileHandle(i,e){const t=this._entries[i],o=t instanceof h;if(t&&o)return t;if(t&&!o)throw new s(...c);if(!t&&!e.create)throw new s(...n);if(!t&&e.create)return this._entries[i]=new h(i)}async removeEntry(i,e){const t=this._entries[i];if(!t)throw new s(...n);await t._destroy(e.recursive),delete this._entries[i]}async _destroy(i){for(let e of Object.values(this._entries)){if(!i)throw new s(...p);await e._destroy(i)}this._entries={},this._deleted=!0}};let d;d=new l(""),_=()=>d});export{h as FileHandle,l as FolderHandle,f as Sink,E as __tla,_ as default};
